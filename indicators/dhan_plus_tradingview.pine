//@version=5
indicator("Dhan+Webhook", overlay=true, max_lines_count=100, max_labels_count=100)

// ==========================
// ðŸ”§ CONFIG
// ==========================
src           = close
maType        = input.string("EHMA", options=["HMA","EHMA","THMA"])
length        = input.int(16)
leftBars      = input.int(33, "SR Left Strength")
rightBars     = input.int(21, "SR Right Strength")
targetPercent = input.float(5, "Target %", step=0.1)
lots          = input.int(4, "Number of Lots", minval=1)
lotSize       = input.int(65, "Lot Size (Qty per lot)", minval=1) // Nifty=75, BankNifty=25, FinNifty=40, etc.
webhookUrl    = input.string("https://webhook.dhan.co", "Webhook URL")
showSRLabels = input.bool(true, "Show S/R Labels")
supportSLPercent = input.float(5, "Support SL Buffer %", step=0.1)

// ==========================
// ðŸ•’ IST TIME FUNCTION
// ==========================
get_ist_time(_time) =>
    ist_offset = 5 * 60 * 60 * 1000 + 30 * 60 * 1000
    str.format("{0,time,HH:mm:ss}", _time + ist_offset)

roundToTick(price) =>
    math.round(price / syminfo.mintick) * syminfo.mintick

// ==========================
// âœ… GLOBAL STRUCTURE PRICES (MUST BE ABOVE FUNCTION)
// ==========================
var float lastSupportPrice    = na
var float lastResistancePrice = na

var line slLine = na

// ==========================
// ðŸ“¡ WEBHOOK FUNCTION  âœ… MUST BE HERE
// ==========================
sendWebhook(string action, float price, int quantity, string orderType, float target = na, float stoploss = na, string tag = "") =>
    payload = '{"action":"' + action + '","price":' + (na(price) ? "null" : str.tostring(price)) + ',"quantity":' + (na(quantity) ? "null" : str.tostring(quantity)) + ',"orderType":"' + orderType + '","target":' + (na(target) ? "null" : str.tostring(target)) + ',"stoploss":' + (na(stoploss) ? "null" : str.tostring(stoploss)) + ',"support":' + (na(lastSupportPrice) ? "null" : str.tostring(lastSupportPrice)) + ',"resistance":' + (na(lastResistancePrice) ? "null" : str.tostring(lastResistancePrice)) + ',"symbol":"' + syminfo.tickerid + '","tag":"' + tag + '"}'
    alert(message=payload, freq=alert.freq_once_per_bar)

// ==========================
// ðŸ“ MA FUNCTIONS
// ==========================
HMA(_src, _len) => ta.wma(2 * ta.wma(_src, math.round(_len / 2)) - ta.wma(_src, _len), math.round(math.sqrt(_len)))
EHMA(_src, _len) => ta.ema(2 * ta.ema(_src, _len) - ta.ema(_src, _len), math.round(math.sqrt(_len)))
THMA(_src, _len) => ta.wma(ta.wma(_src, math.round(_len / 3)) * 3 - ta.wma(_src, math.round(_len / 2)) - ta.wma(_src, _len), _len)

// ==========================
// ðŸ“Š LOCALIZED S/R LOGIC
// ==========================
ph = ta.pivothigh(high, leftBars, rightBars)
pl = ta.pivotlow(low, leftBars, rightBars)

var line lastResLine = na
var line lastSupLine = na


// Resistance Logic
if not na(ph)
    if not na(lastResLine)
        line.set_x2(lastResLine, bar_index[rightBars])
        line.set_extend(lastResLine, extend.none)
    
    lastResLine := line.new(bar_index[rightBars], ph, bar_index, ph, color=color.new(color.red, 20), width=2, extend=extend.right)


    // âœ… SAVE RESISTANCE PRICE
    lastResistancePrice := ph
    if showSRLabels and not na(ph)
        label.new(bar_index[rightBars], ph, "R: " + str.tostring(ph) + "\nTime: " + get_ist_time(time[rightBars]), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Support Logic
if not na(pl)
    if not na(lastSupLine)
        line.set_x2(lastSupLine, bar_index[rightBars])
        line.set_extend(lastSupLine, extend.none)
    
    lastSupLine := line.new(bar_index[rightBars], pl, bar_index, pl, color=color.new(color.green, 20), width=2, extend=extend.right)


    // âœ… SAVE SUPPORT PRICE
    lastSupportPrice := pl
    if showSRLabels and not na(pl)
        label.new(bar_index[rightBars], pl, "S: " + str.tostring(pl) + "\nTime: " + get_ist_time(time[rightBars]), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)



// ==========================
// ðŸ“ˆ MA CALCULATION
// ==========================
ma = maType=="HMA"?HMA(src,length):maType=="EHMA"?EHMA(src,length):THMA(src,length)
fastMA = ma
slowMA = ma[2]

// ==========================
// ðŸ” CROSSOVER LOGIC
// ==========================
buyCross  = ta.crossunder(slowMA, fastMA)
sellCross = ta.crossover(slowMA, fastMA)

// ==========================
// ðŸ§  ADVANCED TRADE STATE
// ==========================
var bool   inTrade      = false
var float  entryPrice   = na
var int    totalQty     = 0
var int    partialExit1 = 0
var int    partialExit2 = 0
var float dynamicSL = na

// Calculate quantities
totalQty := lots * lotSize
firstExitQty = math.floor(totalQty / 2)
// Make sure first exit is even number
firstExitQty := firstExitQty % 2 == 0 ? firstExitQty : firstExitQty + 1
remainingAfterFirst = totalQty - firstExitQty

// Calculate subsequent exit quantities
secondExitQty = math.floor(remainingAfterFirst / 2)
secondExitQty := secondExitQty % 2 == 0 ? secondExitQty : secondExitQty + 1
finalExitQty = remainingAfterFirst - secondExitQty

// ==========================
// ðŸ”’ SUPPORT-BASED TRAILING SL
// ==========================
if inTrade and partialExit1 == 1 and not na(lastSupportPrice) and barstate.isconfirmed
    supportBasedSL = roundToTick(lastSupportPrice * (1 + supportSLPercent / 100))

    // Safety: SL must stay below current price
    supportBasedSL := math.min(supportBasedSL, close * 0.999)

    // SL only moves UP
    if na(dynamicSL) or supportBasedSL > dynamicSL
        dynamicSL := supportBasedSL

        sendWebhook( "MODIFY_SL",na,na,"SL",na,dynamicSL,"SUPPORT_TRAIL_SL"        )

        label.new(bar_index,dynamicSL,"ðŸ”’ SL Trailed to Support" +"\nSL: " + str.tostring(dynamicSL) +"\nSupport: " + str.tostring(lastSupportPrice) +"\nIST: " + get_ist_time(time),style=label.style_label_down,color=color.teal,textcolor=color.white,size=size.small        )



// ==========================
// ðŸš€ ENHANCED SIGNAL LOGIC
// ==========================


// 1. BUY SIGNAL
if buyCross and not inTrade
    inTrade    := true
    entryPrice := low
    partialExit1 := 0
    partialExit2 := 0

    // ENTRY SL FROM SUPPORT
    supportSL = na(lastSupportPrice)? low * 0.99   : roundToTick(lastSupportPrice * (1 + supportSLPercent / 100))

    dynamicSL := supportSL
    dynamicSL := math.min(dynamicSL, entryPrice * 0.999)

    // Send initial buy order
    sendWebhook( "BUY",close,totalQty,"LIMIT",entryPrice * (1 + targetPercent / 100),dynamicSL,"INITIAL_ENTRY"    )

    label.new(bar_index, low, "BUY " + str.tostring(totalQty) + " @ " + str.tostring(close) + "\nTarget: " + str.tostring(entryPrice * (1 + targetPercent / 100)) + "\nSL: " + str.tostring(dynamicSL) + "\nIST: " + get_ist_time(time), style=label.style_label_up, color=color.green, textcolor=color.white)

// 2. FIRST TARGET HIT (Sell 50%)
if inTrade and high >= entryPrice * (1 + targetPercent / 100) and partialExit1 == 0
    partialExit1 := 1
    
    // Send partial exit order
    sendWebhook("SELL", entryPrice * (1 + targetPercent / 100), firstExitQty, "LIMIT", na, na, "PARTIAL_EXIT_1")

    // Move SL to support after partial exit
    dynamicSL := na(lastSupportPrice) ? dynamicSL : roundToTick(lastSupportPrice * (1 + supportSLPercent / 100))
    if not na(slLine)
        line.delete(slLine)

    slLine := line.new(bar_index,dynamicSL,bar_index + 1,dynamicSL,color=color.red,style=line.style_dotted)


    sendWebhook( "MODIFY_SL",na,na,"SL",na,dynamicSL,"SUPPORT_SL_AFTER_PARTIAL"    )

        
    label.new(bar_index, high, "ðŸŽ¯ PARTIAL EXIT (" + str.tostring(firstExitQty) + " qty)" + "\nPrice: " + str.tostring(entryPrice * (1 + targetPercent / 100)) + "\nSL Moved to: " + str.tostring(dynamicSL) + "\nIST: " + get_ist_time(time), color=color.blue, textcolor=color.white, style=label.style_label_down)

// 3. SECOND TARGET HIT (Sell 25% of original)
if inTrade and partialExit1 == 1 and high >= entryPrice * (1 + targetPercent / 100) * (1 + targetPercent / 100) and partialExit2 == 0
    partialExit2 := 1
    
    secondTarget = entryPrice * (1 + targetPercent / 100) * (1 + targetPercent / 100)
    
    sendWebhook("SELL", secondTarget, secondExitQty, "LIMIT", na, na, "PARTIAL_EXIT_2")

    label.new(bar_index, high, "ðŸŽ¯ SECOND EXIT (" + str.tostring(secondExitQty) + " qty)" + "\nPrice: " + str.tostring(secondTarget) + "\nIST: " + get_ist_time(time), color=color.purple, textcolor=color.white, style=label.style_label_down)

// 4. FINAL EXIT (Remaining 25%)
if inTrade and partialExit2 == 1 and high >= entryPrice * math.pow((1 + targetPercent / 100), 3)
    finalTarget = entryPrice * math.pow((1 + targetPercent / 100), 3)
    
    sendWebhook("SELL", finalTarget, finalExitQty, "LIMIT", na, na, "FINAL_EXIT")

    inTrade := false
    dynamicSL := na
    if not na(slLine)
        line.delete(slLine)
        slLine := na

    
    label.new(bar_index, high, "ðŸŽ¯ FINAL EXIT (" + str.tostring(finalExitQty) + " qty)" + "\nPrice: " + str.tostring(finalTarget) + "\nTotal Profit Booked" + "\nIST: " + get_ist_time(time), color=color.orange, textcolor=color.white, style=label.style_label_down)

// 5. STOP LOSS HIT
if inTrade and not na(dynamicSL) and low <= dynamicSL
    exitPrice = dynamicSL
    exitQty = totalQty - (partialExit1 == 1 ? firstExitQty : 0) - (partialExit2 == 1 ? secondExitQty : 0)
    
    sendWebhook("SELL", exitPrice, exitQty, "SL_MARKET", na, na, "STOPLOSS_HIT")

    inTrade := false
    dynamicSL := na
    if not na(slLine)
        line.delete(slLine)
        slLine := na


    
    label.new(bar_index, high, "ðŸ›‘ STOP LOSS HIT\nExit Qty: " + str.tostring(exitQty) + "\nPrice: " + str.tostring(exitPrice) + "\nIST: " + get_ist_time(time), color=color.red, textcolor=color.white, style=label.style_label_down)

// 6. SELL SIGNAL EXIT
if sellCross and inTrade
    exitQty = totalQty - (partialExit1 == 1 ? firstExitQty : 0) - (partialExit2 == 1 ? secondExitQty : 0)
    
    if exitQty > 0
        sendWebhook("SELL", close, exitQty, "MARKET", na, na, "SELL_SIGNAL_EXIT")
 
    inTrade := false
    dynamicSL := na
    if not na(slLine)
        line.delete(slLine)
        slLine := na


    
    label.new(bar_index, high, "SELL SIGNAL EXIT (" + str.tostring(exitQty) + " qty)" + "\nPrice: " + str.tostring(close) + "\nIST: " + get_ist_time(time), style=label.style_label_down, color=color.red, textcolor=color.white)

// ==========================
// ðŸŽ¨ PLOTS
// ==========================
plot(fastMA, color=color.blue, linewidth=2, title="Fast MA")
plot(slowMA, color=color.orange, linewidth=1, style=plot.style_stepline, title="Slow MA")

// Display position info
var table posTable = table.new(position.top_right, 4, 6, bgcolor=color.new(color.gray, 90))
if barstate.islast
    table.cell(posTable, 0, 0, "POSITION INFO", bgcolor=color.blue)
    table.cell(posTable, 0, 1, "In Trade: " + str.tostring(inTrade))
    table.cell(posTable, 0, 2, "Entry: " + (na(entryPrice) ? "N/A" : str.tostring(entryPrice)))
    table.cell(posTable, 0, 3, "Total Qty: " + str.tostring(totalQty))
    table.cell(posTable, 0, 4, "Remaining: " + str.tostring(totalQty - (partialExit1 == 1 ? firstExitQty : 0) - (partialExit2 == 1 ? secondExitQty : 0)))
    table.cell(        posTable,0,5,"Current SL: " + (na(dynamicSL) ? "N/A" : str.tostring(dynamicSL))    )  
